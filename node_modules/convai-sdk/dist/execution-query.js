"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
class ExecutionMatcher {
    /**
     * Initialize the class
     */
    constructor(limit) {
        this.limit = limit || 10;
        this.offset = 0;
        this.filters = [];
        this.mustNot = [];
        this.sort = [];
        this.negateCurrent = false;
    }
    /**
     * Intialize a query to be performed. This method handles the 'key' part of the query
     *
     * @param field - The execution field to compare
     */
    where(field) {
        field = field.trim();
        if (field.length === 0) {
            throw new Error("cannot query blank field");
        }
        if (this.currentItem !== undefined) {
            if (this.negateCurrent) {
                this.mustNot.push(this.currentItem);
            }
            else {
                this.filters.push(this.currentItem);
            }
        }
        this.currentItem = {
            field: field,
            op: ExecutionOperation.EQUALS,
        };
        this.negateCurrent = false;
        return this;
    }
    /**
     * Negate the current execution condition
     */
    not() {
        this.negateCurrent = true;
        return this;
    }
    /**
     * Set the offset on results
     *
     * @param offset - The offset to be set
     */
    setOffset(offset) {
        this.offset = offset;
        return this;
    }
    /**
     * Sort the executions by the field in ascending order
     *
     * @param field - The name of the field
     */
    sortAsc(field) {
        this.sort.push({
            asc: true,
            field
        });
        return this;
    }
    /**
     * Sort the executions by the field in descending order
     *
     * @param field - The name of the field
     */
    sortDesc(field) {
        this.sort.push({
            asc: false,
            field
        });
        return this;
    }
    /**
     * This method handles the 'value' part of the query. Denotes that the return set from where 'key' is equal to 'value'
     *
     * @param value - The value to be compared
     */
    equals(...value) {
        if (this.currentItem === undefined) {
            throw new Error("cannot call equals before calling where");
        }
        if (!this.currentItem.matcher) {
            this.currentItem.matcher = [];
        }
        this.currentItem.op = ExecutionOperation.EQUALS;
        this.currentItem.matcher.push(...value);
        return this;
    }
    /**
     * This method handles the 'value' part of the query. Denotes that the execution data should have the where 'key'
     */
    exists() {
        if (this.currentItem === undefined) {
            throw new Error("cannot call exists before calling where");
        }
        this.currentItem.op = ExecutionOperation.EXISTS;
        return this;
    }
    /**
     * This method handles the 'value' part of the query. Denotes that the return set from the where 'key' starts with 'value'
     *
     * @param prefix - The value to be compared
     */
    hasPrefix(prefix) {
        if (this.currentItem === undefined) {
            throw new Error("cannot call hasPrefix before calling where");
        }
        this.currentItem.op = ExecutionOperation.HAS_PREFIX;
        this.currentItem.matcher = [prefix];
        return this;
    }
    /**
     * This method handles the 'value' part of the query. Denotes that the return set from the where 'key' should be between (low, high) for inclusive = false or [low, high] for inclusive = true
     *
     * @param low - The lower number
     * @param high - The higher number
     * @param inclusive - Specify if the lower and higher numbers should be inclusive or exclusive
     */
    between(low, high, inclusive) {
        if (this.currentItem === undefined) {
            throw new Error("cannot call between before calling where");
        }
        if (inclusive) {
            this.currentItem.op = ExecutionOperation.BETWEEN_INCLUSIVE;
        }
        else {
            this.currentItem.op = ExecutionOperation.BETWEEN_EXCLUSIVE;
        }
        this.currentItem.lowerBound = low;
        this.currentItem.upperBound = high;
        return this;
    }
}
exports.ExecutionMatcher = ExecutionMatcher;
var ExecutionOperation;
(function (ExecutionOperation) {
    ExecutionOperation[ExecutionOperation["EQUALS"] = 0] = "EQUALS";
    ExecutionOperation[ExecutionOperation["EXISTS"] = 1] = "EXISTS";
    ExecutionOperation[ExecutionOperation["BETWEEN_EXCLUSIVE"] = 2] = "BETWEEN_EXCLUSIVE";
    ExecutionOperation[ExecutionOperation["BETWEEN_INCLUSIVE"] = 3] = "BETWEEN_INCLUSIVE";
    ExecutionOperation[ExecutionOperation["HAS_PREFIX"] = 4] = "HAS_PREFIX";
})(ExecutionOperation || (ExecutionOperation = {}));
